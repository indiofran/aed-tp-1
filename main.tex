 \documentclass[10pt,a4paper]{article}

\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex
\usepackage{dirtytalk}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Custom macros
\newcommand{\ciudad}{\ensuremath{\langle \mathsf{String} , \ent \rangle}}
% Custom macros
\newcommand{\matrizEnt}{\TLista{\TLista{\ent}}}

\titulo{Trabajo práctico 1: Especificación y WP}
\subtitulo{En búsqueda del camino}

\fecha{\today}

\materia{Algoritmos Y Estructura de Datos}
\grupo{Grupo QUKDCOGWWYZWJZQBIYWM}

\integrante{Gomez Salaverri, Francisco Nicolas}{550/15}{fsalaverri@dc.uba.ar}
\integrante{Barberón, Federico Joaquín}{112/24}{jfedericobarberonj@gmail.com}
\integrante{Fuertes Vila, Isabel}{474/92}{isblfv@gmail.com}
\integrante{Castelli, Tomás Valentín}{094/23}{tomycastelli@gmail.com}
% Pongan cuantos integrantes quieran

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}


% Document
\begin{document}

\maketitle

\section{Problemas}
A continuación, se presentan los procedimientos solicitados en el enunciado del trabajo, junto con las definiciones, funciones auxiliares y predicados que forman parte de la especificación del problema 'En búsqueda del camino' de este trabajo práctico.

\subsection{Definiciones}
Las siguientes definiciones se utilizan para proporcionar mayor claridad y legibilidad al trabajo.

Ciudad:  \ciudad  \quad siendo $Ciudad_0$ es el nombre de la ciudad y a su vez es el identificador unico de las ciudades, basandonos en el chequeo que realiza la catedra en el punto 2.


\subsection{Procedimientos}


\begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}}{ \TLista{Ciudad}}
	\requiere{todasCiudadesDistintas(ciudades)}
	\asegura{
	|res| \leq |ciudades| \land \\
	\paraTodo[unalinea] {r}{ciudad}{r \in res} \Iff r \in ciudades \land esCiudadGrande(r)
	}
\end{proc}

\begin{proc}{sumaDeHabitantes}
	{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{ \TLista{Ciudad}}

	\requiere{ \\
		|menoresDeCiudades| = |mayoresDeCiudades| \land \\
		todasCiudadesDistintas(menoresDeCiudades) \land \\
		tienenMismosNombres(menoresDeCiudades, mayoresDeCiudades) \\
	}
	\asegura{\\
		|res| = |menoresDeCiudades| \land \\
		tienenMismosNombres(res, menoresDeCiudades) \land \\
		\paraTodo[unalinea]{c}{Ciudad}{c \in res \Then \\ c_1 = cantidadHabitantes(c_0, menoresDeCiudades) + cantidadHabitantes(c_0, mayoresDeCiudades)} \\
	}
\end{proc}

\begin{proc}{hayCamino}{\In distancias : \matrizEnt, in desde: \ent, hasta: \ent}{ \bool}
	\requiere{ 0 \leq desde,hasta < \longitud{distancias} \wedge esMatrizCuadrada(distancias)}
	\asegura{res = \True \Iff existeCamino(distancias, desde, hasta)}
\end{proc}

\begin{proc}{cantidadCaminosNSaltos}{\Inout conexion : \matrizEnt, \In n: \ent}{}
	\requiere{esMatrizConexion(conexion) \land conexion = C_0 \land n \geq 1 }
	\asegura{
	 \existe[unalinea]{s}{\matrizEnt}{|s| = n \yLuego C_0 = s[0] \land conexion = s[|s| -1] \yLuego \\ \paraTodo[unalinea]{i}{\ent}{0\leq i < |s|-1 \implicaLuego esmatrizMultiplo(s[i], s[i+1])} }
	}
\end{proc}


\begin{proc}{caminoMínimo}
  {\In origen:\ent , \In destino: \ent , \In distancias : \TLista{\TLista{\ent}}}
  {\TLista{\ent}}

  \requiere{
    origen \neq destino \\ \wedge existeCamino(distancias, origen, destino)\\ \wedge esMatrizCuadrada(distancias)
  }

  \asegura{
    res = s \Iff \\
    \existe[unalinea]{s}{\TLista{\ent}}{
      secuenciaEnMatriz(s, distancias) \yLuego 
      caminoValido(s, distancias, origen, destino) \implicaLuego \\
      \paraTodo[unalinea]{s'}{\TLista{\ent}}{
        (secuenciaEnMatriz(s', distancias) \yLuego 
         caminoValido(s', distancias, origen, destino))
        \implicaLuego \\
        \sum_{i=0}^{|s|-2} distancias[\;s[i]\;][\;s[i+1]\;]
        \leq 
        \sum_{i=0}^{|s'|-2} distancias[\;s'[i]\;][\;s'[i+1]\;]
      }
    }
  }
\end{proc}


\subsection{Auxiliares}
\aux{cantidadHabitantes}{nombre: \str, ciudades: \TLista{Ciudad}}{\ent}{\\
	\displaystyle\sum_{i = 0}^{|ciudades| - 1} IfThenElse(ciudades[i]_0 = nombre, ciudades[i]_1, 0)
}

\subsection{Predicados}
\pred{todasCiudadesDistintas}{ciudades: \TLista{Ciudad}}{
	\paraTodo[unalinea]{i}{\ent}{enRango(i, ciudades) \implicaLuego \neg \existe[unalinea]{j}{\ent}{(enRango(j, ciudades) \land i \neq j) \yLuego ciudades[i]_0 = ciudades[j]_0}}
}

\pred{tienenMismosNombres}{ciudades1: \TLista{Ciudad}, ciudades2: \TLista{Ciudad}}{
	\paraTodo[unalinea]{c1}{Ciudad}{c1 \in ciudades1 \Then \existe[unalinea]{c2}{Ciudad}{c2 \in ciudades2 \land c1_0 = c2_0}}
}

\pred{ciudadesGrandes}{ciudades: \TLista{Ciudad}}{ \paraTodo {c}{ciudad}{ c \in ciudades \implicaLuego esCiudadGrande(c)}}

\pred{esCiudadGrande}{ciudad: ciudad}{ciudad_0 > 50,000} 

\pred{esMatrizCuadrada}{matriz: \matrizEnt}
{
	\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego \longitud{matriz[i]} = \longitud{matriz}}
}
\pred{existeCamino}{distancias: \matrizEnt, desde: \ent, hasta: \ent} {
	\existe {s} {\TLista{\ent}} {
		secuenciaEnMatriz(s, distancias)  \yLuego caminoValido(s,distancias, desde, hasta)
	}
}
\pred{secuenciaEnMatriz}{secuencia: \TLista{\ent}, matriz: \matrizEnt} {
	\paraTodo {i} {\ent}{enRango(i,secuencia) \implicaLuego 0 \leq secuencia[i] < \longitud{matriz}}
}


\pred{caminoValido}
{camino: \TLista{\ent}, distancias: \matrizEnt, desde: \ent, hasta: \ent}
{
\longitud{camino} \geq 2 \yLuego \\
camino[0] = desde \land  camino[\longitud{camino} -1] = hasta \land \\
\paraTodo[unalinea]{i} {\ent} { 0 \leq i < \longitud{camino} - 1 \\  	\implicaLuego distancias \; [\;camino[i]\;] \; [\;camino[i+1]\;] \neq 0}
}

\pred{esMatrizMultiplo}{A: \matrizEnt, B: \matrizEnt}
{
|A| = |B| \land esMatrizCuadrada(A) \land esMatrizCuadrada(B) \yLuego \\
\paraTodo[unalinea]{i}{\ent}{\paraTodo{j}{\ent}{enRango(j,A) \land enRango(i,A) \implicaLuego \\
 B[i][j] = \sum _{r=0} ^ {|A|-1} A[i][r] * A[r][j]
}
}
}

\pred{esMatrixConexion}{conexion: \matrizEnt}{
esMatrizCuadrada(conexion) \yLuego \\
 \paraTodo[unalinea]{i}{\ent}{\paraTodo{j}{\ent}{enRango(i,conexiones) \land \\enRango(j,conexiones)\implicaLuego \\
 conexiones[i][j] = 1 \lor conexiones[i][j] = 0
}
}}

\pred{enRango}{i: \ent, s: \TLista{T}}
{
	0 \leq i < \longitud{s}
}





\section{Demostraciones de correctitud}

\subsection{Correctiud}
En el siguiente apartado, demostraremos la corrección del código solicitado \say{poblaciónTotal} en relación con la especificación proporcionada para dicho problema.  \say{La función poblaciónTotal recibe una lista de ciudades donde al menos una de ellas es grande (es decir, supera los
	50.000 habitantes) y devuelve la cantidad total de habitantes.}


\begin{algorithm}
\caption{Sumar habitantes de ciudades}
\begin{algorithmic}[1]
\State $res \gets 0$
\State $i \gets 0$
\While{$i < ciudades.length$}
    \State $res \gets res + ciudades[i].habitantes$
    \State $i \gets i + 1$
\EndWhile
\end{algorithmic}
\end{algorithm}

Para probrar al correctitud de este codigo tiene que cumplir se la tripla de Hoare \hoare {\ensuremath{P}}{S}{\ensuremath{Q}}

Segune el teorema de invariante, si existe un predicado \ensuremath{I} tal que.. \\

1. \ensuremath{P}c \ensuremath{\Longrightarrow} I \\
2. \hoare {I \wedge B} {S} {I} \\
3. ($I \wedge  B$) \ensuremath{\Longrightarrow}  \ensuremath{Q}c \\ 

Sea \( P \) la precondición y \( B \) la guarda del bucle `while`.

La relación entre estas condiciones es la siguiente:

\[
P_c \equiv \{ \text{res} = 0 \land i = 0 \}
\]

\[
Q_c \equiv \left\{ \text{res} = \sum_{i=0}^{|\text{ciudades}|-1} \text{ciudades}[i].\text{habitantes} \right\}
\]

\[
B \equiv \{ i < |s| \}
\]

\[
I \equiv \left\{ 0 \leq i \leq |\text{s}| \land \text{res} = \sum_{j=0}^{i-1} \text{ciudades}[j].\text{habitantes} \right\}
\]



Para demostrar que \( P_c \implies I \), verificamos lo siguiente:

1. Demostración de \( 0 \leq i \leq |s| \):

\[
0 \leq i \leq |s| \equiv 0 \leq 0 \leq |s|
\]

Esto es cierto ya que \( i = 0 \) en la precondición \( P_c \), y claramente \( 0 \leq |s| \), donde \( |s| \) es la longitud del array de ciudades. Por lo tanto, se cumple \( 0 \leq 0 \leq |s| \).

2. Demostración de la sumatoria en \( I \):

En \( P_c \), tenemos que \( \text{res} = 0 \). La expresión para la sumatoria en \( I \) es:

\[
\text{res} = \sum_{j=0}^{i-1} \text{ciudades}[j].\text{habitantes}
\]

Cuando \( i = 0 \), la sumatoria va desde \( j = 0 \) hasta \( j = -1 \), lo cual resulta en una sumatoria vacía:

\[
\sum_{j=0}^{-1} \text{ciudades}[j].\text{habitantes} = 0
\]

Por lo tanto, \( \text{res} = 0 \), lo cual coincide con la precondición \( \text{res} = 0 \) en \( P_c \).
\\

Para demostrar que \hoare{I \land B}{S}{I}  $\ensuremath{\iff I \land B}$: 

Sabemos que \hoare{I \land B}{S}{I}  $\ensuremath{\iff I \land B}$ \implica \wp{S}{I}. Entonces:\\



$\wp{S}{I} \equiv  \wp{ res := res + ciudades[i].habitantes; i := i + 1}{0 \leq i \leq |ciudades| \yLuego res = \sum_{j=0}^{i-1} ciudades[j].habitantes} $

$\equiv  \wp{ res := res + ciudades[i].habitantes}{\wp{i := i + 1}{0 \leq i \leq |ciudades| \yLuego res = \sum_{j=0}^{i-1} ciudades[j].habitantes}} $

$\equiv  \wp{ res := res + ciudades[i].habitantes}{0 \leq i+1 \leq |ciudades| \yLuego res = \sum_{j=0}^{i-1 + 1} ciudades[j].habitantes} $

$\equiv  \wp{ res := res + ciudades[i].habitantes}{0 \leq i+1 \leq |ciudades| \yLuego res = \sum_{j=0}^{i} ciudades[j].habitantes} $

$\equiv  \Def{ciudades[i]} \yLuego -1 \leq i \leq |ciudades| -1 \yLuego res + ciudades[i].habitantes = \sum_{j=0}^{i} ciudades[j].habitantes $

$\equiv  0 \leq i \leq |ciudades| \yLuego res = \sum_{j=0}^{i} ciudades[j].habitantes - ciudades[i].habitantes $

$\equiv  0 \leq i \leq |ciudades|  \yLuego res = \sum_{j=0}^{i-1} ciudades[j].habitantes $\\

Entonces $\ensuremath{I \land B}$  \implica \wp{S}{I}? \\

${I \land B}  \equiv  0 \leq i \leq |ciudades|  \yLuego res = \sum_{j=0}^{i-1} ciudades[j].habitantes $


Ahora solo queda probar que  $I \land \neg B$

\[
I \land \neg B \equiv |s| \leq i \leq |s| \land \text{res} = \sum_{j=0}^{i-1} \text{ciudades}[j].\text{habitantes}
\]

\[
\equiv i = |s| \land \text{res} = \sum_{j=0}^{i-1} \text{ciudades}[j].\text{habitantes}
\]

\[
\equiv \text{res} = \sum_{j=0}^{|s|-1} \text{ciudades}[j].\text{habitantes} \equiv Q_c
\]

Donde

\[
I \land \neg B \equiv |s| \leq i \leq |s| \land \text{res} = \sum_{j=0}^{i-1} s[j]
\]

\[
\equiv i = |s| \land \text{res} = \sum_{j=0}^{i-1} s[j]
\]

\[
\equiv \text{res} = \sum_{j=0}^{|s|-1} s[j] \equiv Q_c
\]

\subsection{Correctitud b}
Después de verificar la corrección del código anterior, podemos observar que la precondición implica nuestra WP calculada previamente. Esto, a su vez, demuestra, según la definición de precondición:

Definición: Una precondición es una condición sobre los argumentos que el programador asume como verdadera. Especifica lo que la función requiere para llevar a cabo su tarea correctamente.

En este caso, la precondición establece que \paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \yLuego ciudades[i].habitantes > 50.000}. Esto nos asegura que siempre se devolverá un resultado mayor a 50,000, ya que es un requisito impuesto por la precondición.

Por lo tanto, nuestra implementación, que sigue el procedimiento descrito, suma a res los habitantes de una ciudad. Según la precondición, debe existir al menos una ciudad cuyos habitantes sean más de 50,000. Esto garantiza que el valor de res será mayor a 50,000, ya que siempre existe al menos una ciudad que cumple con dicha condición.

\end{document}
